 // Generated by FPGAstudio 0.04


//--------   Module  ---------
module GenVid (
   input clk,
   output reg [7:0]r,
   output reg [7:0]g,
   output reg [7:0]b,
   output reg hs,
   output reg vs,
   output reg de
   );

localparam width        = 13'd1280;
localparam height       = 13'd720;
localparam frontporch   = 13'd110;
localparam hsync_len    = 13'd40;
localparam backporch    = 13'd220;
localparam v_frontporch = 13'd5;
localparam vsync_len    = 13'd5;
localparam v_backporch  = 13'd20;

localparam hsync_start  = width + frontporch;
localparam hsync_stop   = hsync_start + hsync_len;
localparam fullwidth    = hsync_stop +backporch;
localparam vsync_start  = height + v_frontporch;
localparam vsync_stop   = vsync_start + vsync_len;
localparam fullheight   = vsync_stop + v_backporch;


reg [12:0] CounterX=0;
reg [12:0] CounterY=0;
reg hSync=0;
reg vSync=0;
reg DrawArea=0;

// timing
always @(posedge clk) begin
	DrawArea <= (CounterX<width) && (CounterY<height);
	CounterX <= (CounterX==fullwidth) ? 13'd0 : CounterX+13'd1;
	if (CounterX==fullwidth) 
		CounterY <= (CounterY==fullheight) ? 13'd0 : CounterY+13'd1;
	hSync <= (CounterX>=hsync_start) && (CounterX<hsync_stop);
	vSync <= (CounterY>=vsync_start) && (CounterY<vsync_stop);
end

// pixel pipeline
always @(posedge clk) begin
	if (DrawArea)
		{r,g,b} <= {CounterX[7:0],CounterY[7:0],CounterY[11:4]};
	else
		{r,g,b} <= 24'b0;

    hs<=hSync;
    vs<=vSync;
    de <= DrawArea;
end

endmodule

//----------------------------

//--------   Module  ---------
// module port
//

module HDMI_out(
  input  wire pixclk_x5,
  input  wire pixclk,
  input  wire [7:0] red,
  input  wire [7:0] green,
  input  wire [7:0] blue,
  input  wire hSync,
  input  wire vSync,
  input  wire vde,
  output wire [3:0] gpdi_dp,
  output wire [3:0] gpdi_dn
);

  // 10b8b TMDS encoding of RGB and Sync
  //
  wire [9:0] TMDS_red;
  wire [9:0] TMDS_green;
  wire [9:0] TMDS_blue;

  assign TMDS_red   = {2'b0,red};
  assign TMDS_green = {2'b0,green};
  assign TMDS_blue  = {2'b0,blue};
  // shift out 10 bits each pix clock (2 DDR bits at a 5x rate)
  //
  reg [3:0] ctr_mod5 = 4'b0;
  reg shift_ld = 0;

  always @(posedge pixclk_x5)
  begin
    shift_ld <= (ctr_mod5==4'd4);
    ctr_mod5 <= (ctr_mod5==4'd4) ? 4'd0 : ctr_mod5 + 4'd1;
  end
  
  reg [9:0] shift_R = 0;
  reg [9:0] shift_G = 0;
  reg [9:0] shift_B = 0;
  reg [9:0] shift_C = 0;

  always @(posedge pixclk_x5)
  begin
    shift_R <= shift_ld ? TMDS_red   : {2'b0,shift_R[9:2]};
    shift_G <= shift_ld ? TMDS_green : {2'b0,shift_G[9:2]};
    shift_B <= shift_ld ? TMDS_blue  : {2'b0,shift_B[9:2]};	
    shift_C <= shift_ld ? 10'h3e0    : {2'b0,shift_C[9:2]};
  end

  // (pseudo-) differential DDR driver (pure verilog version)
  //
  assign gpdi_dp[3] = pixclk_x5 ? shift_C[0] : shift_C[1];
  assign gpdi_dp[2] = pixclk_x5 ? shift_R[0] : shift_R[1];
  assign gpdi_dp[1] = pixclk_x5 ? shift_G[0] : shift_G[1];
  assign gpdi_dp[0] = pixclk_x5 ? shift_B[0] : shift_B[1];

  assign gpdi_dn = ~ gpdi_dp;

endmodule

//----------------------------

module top (
	input wire clk_i,
	output wire [3:0]gpdi_dn,
	output wire [3:0]gpdi_dp
	);

 wire de;
 wire hs;
 wire vs;
 wire [3:0]t_gpdi_dn;
 wire [3:0]t_gpdi_dp;
 wire [7:0]b;
 wire [7:0]g;
 wire [7:0]r;

 wire clk_o;
 BUFG cbuffer (.O(clk_o),.I(clk_i));

 GenVid genvid (
     .clk(clk_o),
    .r(r),
    .g(g),
    .b(b),
    .hs(hs),
    .vs(vs),
    .de(de)
    );

 HDMI_out hdmiout (
    .pixclk_x5(clk_o),
    .pixclk(clk_o),
    .red(r),
    .green(g),
    .blue(b),
    .hSync(hs),
    .vSync(vs),
    .vde(de),
    .gpdi_dp(t_gpdi_dp),
    .gpdi_dn(t_gpdi_dn)
    );

 assign gpdi_dn = t_gpdi_dn;
 assign gpdi_dp = t_gpdi_dp;
endmodule
